// Test demonstrating the new predicate instantiation approach
// This shows how predicates are now instantiated directly during action type generation
// instead of using string templates that are parsed at runtime.

using System;
using BehaviorTreeMainProject;
using ModelLoader.ParameterTypes;
using ModelLoader.PredicateTypes;

// Example of how the new generated PickUp action would work:

// 1. Create parameter instances
var pickedObject = new Beam("beam1");
var robot = new Robot("robot1");
var location = new Firstposition("pos1");
var tool = new VacuumGripper("gripper1");

// 2. Create the action instance (predicates are automatically instantiated in constructor)
var blackboard = new Blackboard<FastName>("bolt://localhost:7687", "neo4j", "password");
var pickupAction = new PickUp("pickup", "pickup_instance", blackboard, pickedObject, robot, location, tool);

// 3. The predicates are now already instantiated as State objects:
// - pickupAction.Preconditions contains instantiated IsAt, AtAgent, and HasTool predicates
// - pickupAction.Effects contains instantiated Holding and AtAgent predicates

// 4. Store predicates in blackboard (now much simpler)
pickupAction.StorePredicatesInBlackboard();

// 5. Apply effects when action succeeds
pickupAction.applyEffects();

// Benefits of the new approach:
// 1. No runtime string parsing - predicates are instantiated at compile time
// 2. Better performance - no reflection or string manipulation needed
// 3. Type safety - compiler catches errors in predicate instantiation
// 4. Better IDE support - IntelliSense works for predicate constructors
// 5. Cleaner code - direct instantiation is more readable than string templates

// The generated code looks like this:
/*
private void InitializePredicates()
{
    // Initialize preconditions
    preconditions = new State(StateType.Precondition, new FastName("pickup_preconditions"));
    preconditions.AddPredicate(new FastName("pickup_pre_0"), new IsAt(pickedObject, loc, false));
    preconditions.AddPredicate(new FastName("pickup_pre_1"), new AtAgent(rob, loc, false));
    preconditions.AddPredicate(new FastName("pickup_pre_2"), new HasTool(rob, robTool, false));

    // Initialize effects
    effects = new State(StateType.Effect, new FastName("pickup_effects"));
    effects.AddPredicate(new FastName("pickup_eff_0"), new Holding(rob, pickedObject, false));
    effects.AddPredicate(new FastName("pickup_eff_1"), new AtAgent(rob, loc, false));
}
*/

// This is much cleaner than the old string template approach:
/*
protected override List<string> PreconditionTemplates => new List<string>
{
    "PredicateInstance: isAt(myObject = pickedObject, location = loc, isNegated = false)",
    "PredicateInstance: atAgent(agent = rob, location = loc, isNegated = false)",
    "PredicateInstance: hasTool(agent = rob, tool = robTool, isNegated = false)",
};
*/
