// Test demonstrating the dynamic predicate instantiation approaches
// This shows how predicates are now instantiated dynamically based on the MontiCore model
// instead of being hardcoded to specific predicate types.

// APPROACH 1: Direct Instantiation (USE_DIRECT_INSTANTIATION = true)
// This approach directly instantiates predicate classes using their constructors

/*
Generated PickUp action with direct instantiation:

private void InitializePredicates()
{
    // Initialize preconditions
    preconditions = new State(StateType.Precondition, new FastName("pickup_preconditions"));
    preconditions.AddPredicate(new FastName("pickup_pre_0"), new IsAt(pickedObject, loc, false));
    preconditions.AddPredicate(new FastName("pickup_pre_1"), new AtAgent(rob, loc, false));
    preconditions.AddPredicate(new FastName("pickup_pre_2"), new HasTool(rob, robTool, false));

    // Initialize effects
    effects = new State(StateType.Effect, new FastName("pickup_effects"));
    effects.AddPredicate(new FastName("pickup_eff_0"), new Holding(rob, pickedObject, false));
    effects.AddPredicate(new FastName("pickup_eff_1"), new AtAgent(rob, loc, false));
}
*/

// APPROACH 2: Factory-Based Instantiation (USE_DIRECT_INSTANTIATION = false)
// This approach uses FactoryPredicate to dynamically create predicate instances

/*
Generated PickUp action with factory-based instantiation:

private void InitializePredicates()
{
    // Initialize preconditions
    preconditions = new State(StateType.Precondition, new FastName("pickup_preconditions"));
    preconditions.AddPredicate(new FastName("pickup_pre_0"), 
        FactoryPredicate.Instance.CreatePredicateInstance("isAt", 
            new List<ParameterMapping> { 
                new ParameterMapping("myObject", "pickedObject"), 
                new ParameterMapping("location", "loc") 
            }, blackboard));
    preconditions.AddPredicate(new FastName("pickup_pre_1"), 
        FactoryPredicate.Instance.CreatePredicateInstance("atAgent", 
            new List<ParameterMapping> { 
                new ParameterMapping("agent", "rob"), 
                new ParameterMapping("location", "loc") 
            }, blackboard));
    preconditions.AddPredicate(new FastName("pickup_pre_2"), 
        FactoryPredicate.Instance.CreatePredicateInstance("hasTool", 
            new List<ParameterMapping> { 
                new ParameterMapping("agent", "rob"), 
                new ParameterMapping("tool", "robTool") 
            }, blackboard));

    // Initialize effects
    effects = new State(StateType.Effect, new FastName("pickup_effects"));
    effects.AddPredicate(new FastName("pickup_eff_0"), 
        FactoryPredicate.Instance.CreatePredicateInstance("holding", 
            new List<ParameterMapping> { 
                new ParameterMapping("agent", "rob"), 
                new ParameterMapping("myObject", "pickedObject") 
            }, blackboard));
    effects.AddPredicate(new FastName("pickup_eff_1"), 
        FactoryPredicate.Instance.CreatePredicateInstance("atAgent", 
            new List<ParameterMapping> { 
                new ParameterMapping("agent", "rob"), 
                new ParameterMapping("location", "loc") 
            }, blackboard));
}
*/

// BENEFITS OF THE DYNAMIC APPROACH:

// 1. MODEL-DRIVEN: Predicate types are generated from your MontiCore model
//    - No hardcoded predicate types in the generator
//    - Supports any predicate types defined in your CRF model
//    - Automatically adapts to changes in your model

// 2. FLEXIBLE: Two instantiation strategies available
//    - Direct instantiation: Better performance, compile-time type checking
//    - Factory-based: More dynamic, runtime type resolution

// 3. MAINTAINABLE: 
//    - Generator code is generic and reusable
//    - No need to update generator when adding new predicate types
//    - Consistent with your model-driven architecture

// 4. EXTENSIBLE:
//    - Easy to add new predicate types to your model
//    - Generator automatically supports them
//    - No code changes needed in the generator

// EXAMPLE: Adding a new predicate type to your model
/*
// In your CRF model file:
predicate IsConnected {
    source: Element,
    target: Element
}

// The generator will automatically:
// 1. Generate IsConnected.cs predicate class
// 2. Support IsConnected in action type generation
// 3. Generate proper instantiation code for IsConnected predicates
*/

// CONFIGURATION:
// To switch between approaches, change the USE_DIRECT_INSTANTIATION flag:
// - true: Direct instantiation (new IsAt(...))
// - false: Factory-based instantiation (FactoryPredicate.Instance.CreatePredicateInstance(...))
